package generator

import (
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Niceblueman/cwmp-codegen/internal/models"
)

// C header template
const cHeaderTemplate = `/* Code generated by cwmp-codegen. DO NOT EDIT. */
#ifndef {{.GuardMacro}}
#define {{.GuardMacro}}

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>

{{range .Structs}}
/**
 * {{.Description}}
 */
typedef struct {{.Name}} {
{{range .Fields}}
    /**
     * {{.Description}}
     */
    {{.Type}} {{.Name}}{{.ArraySize}};
{{end}}
} {{.Name}};

{{end}}

#ifdef __cplusplus
}
#endif

#endif /* {{.GuardMacro}} */
`

// CTemplate contains data for the C header template
type CTemplate struct {
	GuardMacro string
	Structs    []CStruct
}

// CStruct represents a C struct
type CStruct struct {
	Name        string
	Description string
	Fields      []CField
}

// CField represents a field in a C struct
type CField struct {
	Name        string
	Description string
	Type        string
	ArraySize   string
}

// GenerateCHeader generates C header code from a data model
func GenerateCHeader(model *models.DataModel, outputDir string) ([]string, error) {
	fileName := sanitize(model.Name) + ".h"
	outputFile := filepath.Join(outputDir, fileName)

	// Create the guard macro
	guardMacro := strings.ToUpper(sanitize(model.Name)) + "_H"

	// Create the template data
	tmplData := CTemplate{
		GuardMacro: guardMacro,
		Structs:    []CStruct{},
	}

	// Convert each object to a C struct
	for _, obj := range model.Objects {
		cStruct := convertObjectToCStruct(obj)
		tmplData.Structs = append(tmplData.Structs, cStruct)
	}

	// Create the output file
	file, err := os.Create(outputFile)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// Parse and execute the template
	tmpl, err := template.New("cheader").Parse(cHeaderTemplate)
	if err != nil {
		return nil, err
	}

	if err := tmpl.Execute(file, tmplData); err != nil {
		return nil, err
	}

	return []string{fileName}, nil
}

// convertObjectToCStruct converts a CWMP object to a C struct
func convertObjectToCStruct(obj models.Object) CStruct {
	cStruct := CStruct{
		Name:        toExportedName(sanitize(obj.Name)),
		Description: obj.Description,
		Fields:      []CField{},
	}

	// Convert parameters to fields
	for _, param := range obj.Parameters {
		cField := CField{
			Name:        sanitizeCFieldName(param.Name),
			Description: param.Description,
			Type:        mapCWMPTypeToCType(param.Type),
			ArraySize:   "", // Default to non-array
		}
		cStruct.Fields = append(cStruct.Fields, cField)
	}

	// Handle nested objects
	for _, childObj := range obj.Objects {
		fieldType := toExportedName(sanitize(childObj.Name)) + "*"
		arraySize := ""

		if childObj.MultiInstance {
			// For multi-instance objects, use a pointer to an array
			// In real implementation, this would need proper memory management
			arraySize = "[MAX_INSTANCES]" // This would need to be defined
		}

		cField := CField{
			Name:        sanitizeCFieldName(childObj.Name),
			Description: childObj.Description,
			Type:        fieldType,
			ArraySize:   arraySize,
		}
		cStruct.Fields = append(cStruct.Fields, cField)
	}

	return cStruct
}

// mapCWMPTypeToCType maps CWMP types to C types
func mapCWMPTypeToCType(cwmpType string) string {
	switch strings.ToLower(cwmpType) {
	case "string":
		return "char*"
	case "int", "integer":
		return "int32_t"
	case "unsignedint", "unsignedinteger":
		return "uint32_t"
	case "boolean", "bool":
		return "bool"
	case "datetime":
		return "char*" // Represented as a string in C
	case "base64":
		return "uint8_t*"
	default:
		return "void*"
	}
}

// sanitizeCFieldName ensures C field names are valid
func sanitizeCFieldName(name string) string {
	name = sanitize(name)

	// Handle C reserved words
	reservedWords := map[string]bool{
		"auto": true, "break": true, "case": true, "char": true,
		"const": true, "continue": true, "default": true, "do": true,
		"double": true, "else": true, "enum": true, "extern": true,
		"float": true, "for": true, "goto": true, "if": true,
		"int": true, "long": true, "register": true, "return": true,
		"short": true, "signed": true, "sizeof": true, "static": true,
		"struct": true, "switch": true, "typedef": true, "union": true,
		"unsigned": true, "void": true, "volatile": true, "while": true,
	}

	if reservedWords[name] {
		return name + "_"
	}

	return name
}
