package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Niceblueman/cwmp-codegen/internal/models"
)

// Golang struct template
const golangStructTemplate = `// Code generated by cwmp-codegen. DO NOT EDIT.
package {{.PackageName}}

{{range .Objects}}
// {{.Name}} {{.Description}}
type {{.GoName}} struct {
{{range .Parameters}}
	// {{.Description}}
	{{.GoName}} {{.GoType}} {{.GoTags}}
{{end}}
{{range .ChildObjects}}
	{{.GoName}} {{.GoType}} {{.GoTags}}
{{end}}
}
{{end}}
`

// GoTemplate contains data for the Golang template
type GoTemplate struct {
	PackageName string
	Objects     []GoObject
}

// GoObject represents a Golang struct
type GoObject struct {
	Name         string
	GoName       string
	Description  string
	Parameters   []GoParameter
	ChildObjects []GoChildObject
}

// GoParameter represents a field in a Golang struct
type GoParameter struct {
	Name        string
	GoName      string
	Description string
	GoType      string
	GoTags      string
}

// GoChildObject represents a nested object in a Golang struct
type GoChildObject struct {
	Name   string
	GoName string
	GoType string
	GoTags string
}

// GenerateGolang generates Golang code from a data model
func GenerateGolang(model *models.DataModel, outputDir string) ([]string, error) {
	packageName := strings.ToLower(sanitize(model.Name))
	outputFile := filepath.Join(outputDir, packageName+".go")

	// Create the template data
	tmplData := GoTemplate{
		PackageName: packageName,
		Objects:     []GoObject{},
	}

	// Convert each object to a Golang struct
	for _, obj := range model.Objects {
		goObj := convertObjectToGoStruct(obj)
		tmplData.Objects = append(tmplData.Objects, goObj)
	}

	// Create the output file
	file, err := os.Create(outputFile)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// Parse and execute the template
	tmpl, err := template.New("golang").Parse(golangStructTemplate)
	if err != nil {
		return nil, err
	}

	if err := tmpl.Execute(file, tmplData); err != nil {
		return nil, err
	}

	return []string{packageName + ".go"}, nil
}

// convertObjectToGoStruct converts a CWMP object to a Golang struct
func convertObjectToGoStruct(obj models.Object) GoObject {
	goObj := GoObject{
		Name:         obj.Name,
		GoName:       toExportedName(sanitize(obj.Name)),
		Description:  obj.Description,
		Parameters:   []GoParameter{},
		ChildObjects: []GoChildObject{},
	}

	// Convert parameters to struct fields
	for _, param := range obj.Parameters {
		goParam := GoParameter{
			Name:        param.Name,
			GoName:      toExportedName(sanitize(param.Name)),
			Description: param.Description,
			GoType:      mapCWMPTypeToGoType(param.Type),
			GoTags:      fmt.Sprintf("`xml:\"%s,omitempty\"`", param.Name),
		}
		goObj.Parameters = append(goObj.Parameters, goParam)
	}

	// Handle nested objects
	for _, childObj := range obj.Objects {
		var goType string
		if childObj.MultiInstance {
			goType = "[]" + toExportedName(sanitize(childObj.Name))
		} else {
			goType = toExportedName(sanitize(childObj.Name))
		}
		childGoObj := GoChildObject{
			Name:   childObj.Name,
			GoName: toExportedName(sanitize(childObj.Name)),
			GoType: goType,
			GoTags: fmt.Sprintf("`xml:\"%s,omitempty\"`", childObj.Name),
		}
		goObj.ChildObjects = append(goObj.ChildObjects, childGoObj)
	}

	return goObj
}

// mapCWMPTypeToGoType maps CWMP types to Golang types
func mapCWMPTypeToGoType(cwmpType string) string {
	switch strings.ToLower(cwmpType) {
	case "string":
		return "string"
	case "int", "integer", "unsignedint", "unsignedinteger":
		return "int"
	case "boolean", "bool":
		return "bool"
	case "datetime":
		return "time.Time"
	case "base64":
		return "[]byte"
	default:
		return "interface{}"
	}
}

// Helper functions
func sanitize(name string) string {
	// Remove special characters
	name = strings.ReplaceAll(name, ".", "_")
	name = strings.ReplaceAll(name, "-", "_")
	name = strings.ReplaceAll(name, ":", "_")
	name = strings.ReplaceAll(name, " ", "_")
	return name
}

func toExportedName(name string) string {
	if name == "" {
		return ""
	}
	return strings.ToUpper(name[:1]) + name[1:]
}
