package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Niceblueman/cwmp-codegen/internal/models"
)

// Golang message template aligned with the example format
const golangMessageTemplate = `// Code generated by cwmp-codegen. DO NOT EDIT.
package {{.PackageName}}

import (
	"encoding/xml"
	"fmt"
	xmlx "github.com/jteeuwen/go-pkg-xmlx"
	"time"
)

// {{.GoName}} {{.Description | formatComment}}
type {{.GoName}} struct {
	ID      string
	Name    string
	NoMore  int
{{range .Parameters}}
	{{.GoName}} {{.GoType}} {{if .Description}}// {{.Description | formatComment}}{{end}}
{{end}}
}

type {{.LowerName}}BodyStruct struct {
	Body {{.LowerName}}Struct ` + "`xml:\"cwmp:{{.GoName}}\"`" + `
}

type {{.LowerName}}Struct struct {
{{range .Parameters}}
	{{.GoName}} {{.GoType}} {{.GoTags}}
{{end}}
}

// New{{.GoName}} creates a new {{.GoName}} object
func New{{.GoName}}() *{{.GoName}} {
	m := &{{.GoName}}{}
	m.ID = m.GetID()
	m.Name = m.GetName()
	return m
}

// GetID gets the message ID
func (msg *{{.GoName}}) GetID() string {
	if len(msg.ID) < 1 {
		msg.ID = fmt.Sprintf("ID:intrnl.unset.id.%s%d.%d", msg.GetName(), time.Now().Unix(), time.Now().UnixNano())
	}
	return msg.ID
}

// GetName gets the message name
func (msg *{{.GoName}}) GetName() string {
	return "{{.GoName}}"
}

// CreateXML encodes into XML
func (msg *{{.GoName}}) CreateXML() ([]byte, error) {
	env := Envelope{}
	env.XmlnsEnv = "http://schemas.xmlsoap.org/soap/envelope/"
	env.XmlnsEnc = "http://schemas.xmlsoap.org/soap/encoding/"
	env.XmlnsXsd = "http://www.w3.org/2001/XMLSchema"
	env.XmlnsXsi = "http://www.w3.org/2001/XMLSchema-instance"
	env.XmlnsCwmp = "urn:dslforum-org:cwmp-1-0"
	id := IDStruct{Attr: "1", Value: msg.GetID()}
	env.Header = HeaderStruct{ID: id, NoMore: msg.NoMore}
	
	// Create the message struct
	{{.LowerName}} := {{.LowerName}}Struct{
{{range .Parameters}}
		{{.GoName}}: msg.{{.GoName}},
{{end}}
	}
	
	env.Body = {{.LowerName}}BodyStruct{ {{.LowerName}} }
	output, err := xml.MarshalIndent(env, "  ", "    ")
	if err != nil {
		return nil, err
	}
	return output, nil
}

// Parse decodes from XML
func (msg *{{.GoName}}) Parse(doc *xmlx.Document) error {
	// Get ID from header
	idNode := doc.SelectNode("*", "ID")
	if idNode != nil {
		msg.ID = idNode.GetValue()
	}
	
	// Get parameter values based on specific message type
	{{if eq .GoName "GetParameterValues"}}
	// For GetParameterValues, extract parameter names array
	paramNodes := doc.SelectNodes("*", "string")
	for _, node := range paramNodes {
		if value := strings.TrimSpace(node.GetValue()); value != "" {
			msg.ParameterNames = append(msg.ParameterNames, value)
		}
	}
	{{else if eq .GoName "GetParameterValuesResponse"}}
	// For GetParameterValuesResponse, extract parameter name-value pairs
	paramsNode := doc.SelectNode("*", "ParameterList")
	if paramsNode != nil && len(strings.TrimSpace(paramsNode.String())) > 0 {
		params := make(map[string]string)
		for _, param := range paramsNode.Children {
			if len(strings.TrimSpace(param.String())) > 0 {
				name := param.SelectNode("", "Name").GetValue()
				value := param.SelectNode("", "Value").GetValue()
				params[name] = value
			}
		}
		msg.Values = params
	}
	{{else if eq .GoName "SetParameterValues"}}
	// For SetParameterValues, extract parameter key and values
	keyNode := doc.SelectNode("*", "ParameterKey") 
	if keyNode != nil {
		msg.ParameterKey = keyNode.GetValue()
	}
	
	paramsNode := doc.SelectNode("*", "ParameterList")
	if paramsNode != nil && len(strings.TrimSpace(paramsNode.String())) > 0 {
		params := make(map[string]ValueStruct)
		for _, param := range paramsNode.Children {
			if len(strings.TrimSpace(param.String())) > 0 {
				nameNode := param.SelectNode("", "Name")
				valueNode := param.SelectNode("", "Value")
				if nameNode != nil && valueNode != nil {
					name := nameNode.GetValue()
					valType := valueNode.GetAttr("xsi:type", "type")
					value := valueNode.GetValue()
					params[name] = ValueStruct{Type: valType, Value: value}
				}
			}
		}
		msg.Params = params
	}
	{{else if eq .GoName "SetParameterValuesResponse"}}
	// For SetParameterValuesResponse
	statusNode := doc.SelectNode("*", "Status")
	if statusNode != nil {
		msg.Status, _ = strconv.Atoi(statusNode.GetValue())
	}
	{{else if eq .GoName "Inform"}}
	// For Inform message
	deviceIdNode := doc.SelectNode("*", "DeviceId")
	if deviceIdNode != nil {
		msg.DeviceID.Manufacturer = deviceIdNode.SelectNode("", "Manufacturer").GetValue()
		msg.DeviceID.OUI = deviceIdNode.SelectNode("", "OUI").GetValue()
		msg.DeviceID.ProductClass = deviceIdNode.SelectNode("", "ProductClass").GetValue()
		msg.DeviceID.SerialNumber = deviceIdNode.SelectNode("", "SerialNumber").GetValue()
	}

	// Extract events
	eventNodes := doc.SelectNodes("*", "EventStruct")
	events := make(map[string]string)
	for _, eventNode := range eventNodes {
		code := eventNode.SelectNode("", "EventCode").GetValue()
		key := eventNode.SelectNode("", "CommandKey").GetValue()
		events[code] = key
	}
	msg.Events = events

	// Extract parameters
	params := make(map[string]string)
	paramValueNodes := doc.SelectNodes("*", "ParameterValueStruct")
	for _, paramNode := range paramValueNodes {
		nameNode := paramNode.SelectNode("", "Name")
		valueNode := paramNode.SelectNode("", "Value")
		if nameNode != nil && valueNode != nil {
			name := nameNode.GetValue()
			value := valueNode.GetValue()
			params[name] = value
		}
	}
	msg.Params = params
	{{end}}
	
	return nil
}
`

// TR-069 specific template for parameter accessors
const parameterAccessorTemplate = `// Code generated by cwmp-codegen. DO NOT EDIT.
package {{.PackageName}}

// TR069Helper provides helper functions for working with TR-069 parameters
type TR069Helper struct {
	// Add any fields needed for the helper
}

// NewTR069Helper creates a new TR-069 helper
func NewTR069Helper() *TR069Helper {
	return &TR069Helper{}
}

// NormalizeParameterPath ensures a path has the correct format for TR-069
func (h *TR069Helper) NormalizeParameterPath(path string) string {
	// Make sure path ends with a dot if it's an object path
	if path != "" && !strings.HasSuffix(path, ".") {
		path = path + "."
	}
	return path
}

// ParseParameterPath parses a TR-069 parameter path into components
func (h *TR069Helper) ParseParameterPath(path string) []string {
	return strings.Split(path, ".")
}

// GetParameterObjectPath returns the object path for a parameter
func (h *TR069Helper) GetParameterObjectPath(paramPath string) string {
	parts := strings.Split(paramPath, ".")
	if len(parts) <= 1 {
		return ""
	}
	// Return all but the last component (param name)
	return strings.Join(parts[:len(parts)-1], ".") + "."
}

// IsMultiInstanceObject checks if an object path represents a multi-instance object
func (h *TR069Helper) IsMultiInstanceObject(objectPath string) bool {
	// Check if path contains "{i}" placeholder or a numeric index
	return strings.Contains(objectPath, "{i}") || regexp.MustCompile("\\.(\\d+)\\.").MatchString(objectPath)
}

// GetInstanceIds extracts instance IDs from a path
func (h *TR069Helper) GetInstanceIds(path string) []string {
	r := regexp.MustCompile("\\.(\\d+)\\.")
	matches := r.FindAllStringSubmatch(path, -1)
	
	result := make([]string, 0, len(matches))
	for _, match := range matches {
		if len(match) > 1 {
			result = append(result, match[1])
		}
	}
	
	return result
}
`

// Common types template for XML envelope handling
const commonTypesTemplate = `// Code generated by cwmp-codegen. DO NOT EDIT.
package {{.PackageName}}

import (
	"encoding/xml"
	"fmt"
	"github.com/jteeuwen/go-pkg-xmlx"
	"regexp"
	"strconv"
	"time"
)

// Constants for XML types
const (
	XsdString   = "xsd:string"
	XsdUnsignedInt = "xsd:unsignedInt"
	XsdInt      = "xsd:int"
	XsdBoolean  = "xsd:boolean"
	XsdDateTime = "xsd:dateTime"
	XsdBase64   = "xsd:base64"
)

// Message interface for CWMP messages
type Message interface {
	GetID() string
	GetName() string
	CreateXML() ([]byte, error)
	Parse(doc *xmlx.Document) error
}

// Envelope represents the SOAP envelope
type Envelope struct {
	XMLName   xml.Name     ` + "`xml:\"http://schemas.xmlsoap.org/soap/envelope/ Envelope\"`" + `
	XmlnsEnv  string       ` + "`xml:\"xmlns:SOAP-ENV,attr\"`" + `
	XmlnsEnc  string       ` + "`xml:\"xmlns:SOAP-ENC,attr\"`" + `
	XmlnsXsd  string       ` + "`xml:\"xmlns:xsd,attr\"`" + `
	XmlnsXsi  string       ` + "`xml:\"xmlns:xsi,attr\"`" + `
	XmlnsCwmp string       ` + "`xml:\"xmlns:cwmp,attr\"`" + `
	Header    HeaderStruct ` + "`xml:\"http://schemas.xmlsoap.org/soap/envelope/ Header\"`" + `
	Body      interface{}  ` + "`xml:\"http://schemas.xmlsoap.org/soap/envelope/ Body\"`" + `
}

// HeaderStruct represents the SOAP header
type HeaderStruct struct {
	ID     IDStruct    ` + "`xml:\"cwmp:ID\"`" + `
	NoMore interface{} ` + "`xml:\"cwmp:NoMoreRequests,omitempty\"`" + `
}

// IDStruct represents the ID in the SOAP header
type IDStruct struct {
	Attr  string ` + "`xml:\"SOAP-ENV:mustUnderstand,attr\"`" + `
	Value string ` + "`xml:\",chardata\"`" + `
}

// NodeStruct represents a generic node with type attribute
type NodeStruct struct {
	Type  interface{} ` + "`xml:\"xsi:type,attr\"`" + `
	Value string      ` + "`xml:\",chardata\"`" + `
}

// EventStruct represents TR-069 events array
type EventStruct struct {
	Type   string            ` + "`xml:\"SOAP-ENC:arrayType,attr\"`" + `
	Events []EventNodeStruct ` + "`xml:\"EventStruct\"`" + `
}

// EventNodeStruct represents a single event in TR-069
type EventNodeStruct struct {
	EventCode  NodeStruct ` + "`xml:\"EventCode\"`" + `
	CommandKey string     ` + "`xml:\"CommandKey\"`" + `
}

// ParameterListStruct represents parameter list
type ParameterListStruct struct {
	Type   string                 ` + "`xml:\"SOAP-ENC:arrayType,attr\"`" + `
	Params []ParameterValueStruct ` + "`xml:\"ParameterValueStruct\"`" + `
}

// ParameterValueStruct represents parameter value pair
type ParameterValueStruct struct {
	Name  NodeStruct ` + "`xml:\"Name\"`" + `
	Value NodeStruct ` + "`xml:\"Value\"`" + `
}

// ValueStruct represents a value with type info
type ValueStruct struct {
	Type  string
	Value string
}

// DeviceIDStruct represents the device identification
type DeviceIDStruct struct {
	Manufacturer string ` + "`xml:\"Manufacturer\"`" + `
	OUI string ` + "`xml:\"OUI\"`" + `
	ProductClass string ` + "`xml:\"ProductClass\"`" + `
	SerialNumber string ` + "`xml:\"SerialNumber\"`" + `
}

// ParseXML parses XML data into a Message
func ParseXML(data []byte) (msg Message, err error) {
	doc := xmlx.New()
	err = doc.LoadBytes(data, nil)
	if err != nil {
		return nil, err
	}

	// Determine the message type by checking nodes in the body
	if node := doc.SelectNode("*", "Inform"); node != nil {
		msg = NewInform()
		err = msg.Parse(doc)
	} else if node := doc.SelectNode("*", "GetParameterValues"); node != nil {
		msg = NewGetParameterValues()
		err = msg.Parse(doc)
	} else if node := doc.SelectNode("*", "GetParameterValuesResponse"); node != nil {
		msg = NewGetParameterValuesResponse()
		err = msg.Parse(doc)
	} else if node := doc.SelectNode("*", "SetParameterValues"); node != nil {
		msg = NewSetParameterValues()
		err = msg.Parse(doc)
	} else if node := doc.SelectNode("*", "SetParameterValuesResponse"); node != nil {
		msg = NewSetParameterValuesResponse()
		err = msg.Parse(doc)
	} else if node := doc.SelectNode("*", "GetRPCMethods"); node != nil {
		msg = NewGetRPCMethods()
		err = msg.Parse(doc)
	} else if node := doc.SelectNode("*", "GetRPCMethodsResponse"); node != nil {
		msg = NewGetRPCMethodsResponse()
		err = msg.Parse(doc)
	} else if node := doc.SelectNode("*", "Fault"); node != nil {
		msg = NewFault()
		err = msg.Parse(doc)
	}

	return msg, err
}
`

// GoTemplate contains data for the Golang template
type GoTemplate struct {
	PackageName string
	Objects     []GoObject
}

// GoObject represents a Golang struct
type GoObject struct {
	Name            string
	GoName          string
	LowerName       string
	Description     string
	Parameters      []GoParameter
	ChildObjects    []GoChildObject
	Path            string
	FullPath        string
	IsMultiInstance bool
}

// GoParameter represents a field in a Golang struct
type GoParameter struct {
	Name        string
	GoName      string
	Description string
	GoType      string
	GoTags      string
	FullPath    string
}

// GoChildObject represents a nested object in a Golang struct
type GoChildObject struct {
	Name            string
	GoName          string
	GoType          string
	GoTags          string
	IsMultiInstance bool
	FullPath        string
}

// GenerateGolang generates Golang code from a data model
func GenerateGolang(model *models.DataModel, outputDir string) ([]string, error) {
	packageName := "messages" // Force package name to match example
	outputFiles := []string{}

	// Generate common types first
	commonTypesFile := filepath.Join(outputDir, "common_types.go")

	// Create template data for common types
	commonTmplData := struct {
		PackageName string
	}{
		PackageName: packageName,
	}

	// Create the common types file
	file, err := os.Create(commonTypesFile)
	if err != nil {
		return nil, err
	}

	// Parse and execute the common types template
	tmpl, err := template.New("common_types").Parse(commonTypesTemplate)
	if err != nil {
		file.Close()
		return nil, err
	}

	if err := tmpl.Execute(file, commonTmplData); err != nil {
		file.Close()
		return nil, err
	}
	file.Close()
	outputFiles = append(outputFiles, "common_types.go")

	// Generate TR-069 helper file
	helperFile := filepath.Join(outputDir, "tr069_helper.go")
	file, err = os.Create(helperFile)
	if err != nil {
		return outputFiles, err
	}

	// Parse and execute the parameter accessor template
	tmpl, err = template.New("param_accessor").Parse(parameterAccessorTemplate)
	if err != nil {
		file.Close()
		return outputFiles, err
	}

	if err := tmpl.Execute(file, commonTmplData); err != nil {
		file.Close()
		return outputFiles, err
	}
	file.Close()
	outputFiles = append(outputFiles, "tr069_helper.go")

	// Create template functions for formatting comments
	funcMap := template.FuncMap{
		"formatComment": formatComment,
	}

	// Generate a separate file for each object
	for _, obj := range model.Objects {
		goObj := convertObjectToGoStruct(obj)
		fileName := goObj.GoName + ".go"
		outputFile := filepath.Join(outputDir, fileName)

		// Create the output file
		file, err := os.Create(outputFile)
		if err != nil {
			return outputFiles, err
		}

		// Parse and execute the template with function map
		tmpl, err := template.New("golang").Funcs(funcMap).Parse(golangMessageTemplate)
		if err != nil {
			file.Close()
			return outputFiles, err
		}

		// Add lowercase name for auxiliary structs
		goObj.LowerName = strings.ToLower(goObj.GoName[:1]) + goObj.GoName[1:]

		// Create a simple template data with just this object
		tmplData := struct {
			PackageName string
			GoName      string
			LowerName   string
			Description string
			Parameters  []GoParameter
		}{
			PackageName: packageName,
			GoName:      goObj.GoName,
			LowerName:   goObj.LowerName,
			Description: goObj.Description,
			Parameters:  goObj.Parameters,
		}

		if err := tmpl.Execute(file, tmplData); err != nil {
			file.Close()
			return outputFiles, err
		}

		file.Close()
		outputFiles = append(outputFiles, fileName)
	}

	return outputFiles, nil
}

// formatComment formats a comment by replacing newlines with spaces and condensing whitespace
func formatComment(comment string) string {
	if comment == "" {
		return ""
	}

	// Replace double apostrophes with quotes
	comment = strings.ReplaceAll(comment, "''", "\"")

	// Replace newlines and extra whitespace with a single space
	comment = strings.ReplaceAll(comment, "\n", " ")

	// Remove leading/trailing whitespace
	comment = strings.TrimSpace(comment)

	// Collapse multiple spaces into one
	for strings.Contains(comment, "  ") {
		comment = strings.ReplaceAll(comment, "  ", " ")
	}

	return sanitizeGoComment(comment)
}

// convertObjectToGoStruct converts a CWMP object to a Golang struct
func convertObjectToGoStruct(obj models.Object) GoObject {
	// Create basic Go object with path information from enhanced object model
	goObj := GoObject{
		Name:            obj.Name,
		GoName:          toExportedName(sanitize(obj.Name)),
		LowerName:       strings.ToLower(sanitize(obj.Name[:1])) + sanitize(obj.Name[1:]),
		Description:     obj.Description,
		Parameters:      []GoParameter{},
		ChildObjects:    []GoChildObject{},
		Path:            obj.Path,
		FullPath:        obj.GetPath(),
		IsMultiInstance: obj.IsMultiInstance(),
	}

	// Convert parameters to struct fields with full path information
	// We'll use a map to track parameter names to avoid duplication
	paramNames := make(map[string]bool)

	for _, param := range obj.Parameters {
		// Skip if we've already added this parameter
		if paramNames[param.Name] {
			continue
		}

		goParam := GoParameter{
			Name:        param.Name,
			GoName:      toExportedName(sanitize(param.Name)),
			Description: param.Description,
			GoType:      mapCWMPTypeToGoType(param.Type),
			GoTags:      fmt.Sprintf("`xml:\"%s,omitempty\"`", param.Name),
			FullPath:    param.GetFullPath(),
		}
		goObj.Parameters = append(goObj.Parameters, goParam)

		// Mark this parameter name as processed
		paramNames[param.Name] = true
	}

	// Handle nested objects with proper path information
	for _, childObj := range obj.Objects {
		var goType string
		isMultiInstance := childObj.IsMultiInstance()

		// Use slice for multi-instance objects
		if isMultiInstance {
			goType = "[]" + toExportedName(sanitize(childObj.BaseName))
		} else {
			goType = toExportedName(sanitize(childObj.BaseName))
		}

		childGoObj := GoChildObject{
			Name:            childObj.Name,
			GoName:          toExportedName(sanitize(childObj.BaseName)),
			GoType:          goType,
			GoTags:          fmt.Sprintf("`xml:\"%s,omitempty\"`", childObj.BaseName),
			IsMultiInstance: isMultiInstance,
			FullPath:        childObj.GetPath(),
		}
		goObj.ChildObjects = append(goObj.ChildObjects, childGoObj)
	}

	return goObj
}

// mapCWMPTypeToGoType maps CWMP types to Golang types
func mapCWMPTypeToGoType(cwmpType string) string {
	switch strings.ToLower(cwmpType) {
	case "string":
		return "string"
	case "int", "integer", "unsignedint", "unsignedinteger":
		return "int"
	case "boolean", "bool":
		return "bool"
	case "datetime":
		return "time.Time"
	case "base64":
		return "[]byte"
	case "list":
		return "[]string"
	default:
		return "interface{}"
	}
}

// Helper functions
func sanitize(name string) string {
	// Handle TR-069 object paths properly
	name = strings.TrimSuffix(name, ".") // Remove trailing dot if present

	// Handle {i} placeholders specially
	name = strings.ReplaceAll(name, "{i}", "Instance")

	// Remove special characters
	name = strings.ReplaceAll(name, ".", "_")
	name = strings.ReplaceAll(name, "-", "_")
	name = strings.ReplaceAll(name, ":", "_")
	name = strings.ReplaceAll(name, " ", "_")

	return name
}

// sanitizeGoComment properly formats a comment for Go code
func sanitizeGoComment(comment string) string {
	if comment == "" {
		return ""
	}

	// Replace double apostrophes with quotes
	comment = strings.ReplaceAll(comment, "''", "\"")

	// Split the comment into lines
	lines := strings.Split(comment, "\n")

	// Format each line to start with //
	for i, line := range lines {
		// Trim spaces from line
		line = strings.TrimSpace(line)
		// Skip empty lines
		if line == "" {
			lines[i] = ""
			continue
		}
		// Ensure each line starts with //
		lines[i] = "// " + line
	}

	// Join lines back together
	return strings.Join(lines, "\n")
}

func toExportedName(name string) string {
	if name == "" {
		return ""
	}
	return strings.ToUpper(name[:1]) + name[1:]
}
