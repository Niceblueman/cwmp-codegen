package generator

import (
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Niceblueman/cwmp-codegen/internal/models"
)

// TypeScript interface template
const tsInterfaceTemplate = `// Code generated by cwmp-codegen. DO NOT EDIT.

{{range .Interfaces}}
/**
 * {{.Description}}
 */
export interface {{.Name}} {
{{range .Properties}}
  /**
   * {{.Description}}
   */
  {{.Name}}{{.Optional}}: {{.Type}};
{{end}}
}

{{end}}
`

// TypeScriptTemplate contains data for the TypeScript template
type TypeScriptTemplate struct {
	Interfaces []TSInterface
}

// TSInterface represents a TypeScript interface
type TSInterface struct {
	Name        string
	Description string
	Properties  []TSProperty
}

// TSProperty represents a property in a TypeScript interface
type TSProperty struct {
	Name        string
	Description string
	Type        string
	Optional    string
}

// GenerateTypeScript generates TypeScript code from a data model
func GenerateTypeScript(model *models.DataModel, outputDir string) ([]string, error) {
	fileName := sanitize(model.Name) + ".ts"
	outputFile := filepath.Join(outputDir, fileName)

	// Create the template data
	tmplData := TypeScriptTemplate{
		Interfaces: []TSInterface{},
	}

	// Convert each object to a TypeScript interface
	for _, obj := range model.Objects {
		tsInterface := convertObjectToTSInterface(obj)
		tmplData.Interfaces = append(tmplData.Interfaces, tsInterface)
	}

	// Create the output file
	file, err := os.Create(outputFile)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	// Parse and execute the template
	tmpl, err := template.New("typescript").Parse(tsInterfaceTemplate)
	if err != nil {
		return nil, err
	}

	if err := tmpl.Execute(file, tmplData); err != nil {
		return nil, err
	}

	return []string{fileName}, nil
}

// convertObjectToTSInterface converts a CWMP object to a TypeScript interface
func convertObjectToTSInterface(obj models.Object) TSInterface {
	tsInterface := TSInterface{
		Name:        toExportedName(sanitize(obj.Name)),
		Description: obj.Description,
		Properties:  []TSProperty{},
	}

	// Convert parameters to properties
	for _, param := range obj.Parameters {
		tsProperty := TSProperty{
			Name:        sanitizeTsPropertyName(param.Name),
			Description: param.Description,
			Type:        mapCWMPTypeToTSType(param.Type),
			Optional:    "?", // Make all properties optional by default
		}
		tsInterface.Properties = append(tsInterface.Properties, tsProperty)
	}

	// Handle nested objects
	for _, childObj := range obj.Objects {
		propType := toExportedName(sanitize(childObj.Name))
		if childObj.MultiInstance {
			propType = propType + "[]"
		}

		tsProperty := TSProperty{
			Name:        sanitizeTsPropertyName(childObj.Name),
			Description: childObj.Description,
			Type:        propType,
			Optional:    "?",
		}
		tsInterface.Properties = append(tsInterface.Properties, tsProperty)
	}

	return tsInterface
}

// mapCWMPTypeToTSType maps CWMP types to TypeScript types
func mapCWMPTypeToTSType(cwmpType string) string {
	switch strings.ToLower(cwmpType) {
	case "string":
		return "string"
	case "int", "integer", "unsignedint", "unsignedinteger":
		return "number"
	case "boolean", "bool":
		return "boolean"
	case "datetime":
		return "Date"
	case "base64":
		return "string"
	default:
		return "any"
	}
}

// sanitizeTsPropertyName ensures TypeScript property names are valid
func sanitizeTsPropertyName(name string) string {
	name = sanitize(name)

	// Handle TypeScript reserved words
	reservedWords := map[string]bool{
		"class": true, "interface": true, "type": true, "function": true,
		"import": true, "export": true, "extends": true, "implements": true,
	}

	if reservedWords[strings.ToLower(name)] {
		return name + "_"
	}

	return name
}
